#!/usr/bin/perl

use strict;
use warnings;

use Getopt::Long::Descriptive;
use DBI;
use Data::Compare;

# TODO: variable glossary

my $hostname = 'localhost';
my $port     = '3306';
my $database = 'grammar';
my $user     = 'grammaruser';
my $pass     = 'nunya';
my $dsn      = "DBI:mysql:database=$database;host=$hostname;port=$port";

my ( $getOpt, $usage ) =
  describe_options( 'parse %o <some-arg>',
                    [ 'file|f=s', "file containing text to parse", { required => 1 } ],
                    [],
                    [ 'verbose|v', "print extra stuff" ],
                    [ 'help',      "print usage message and exit" ], );

print( $usage->text ), exit if $getOpt->help;

use Syntactic::Practice::Schema;
my $schema = Syntactic::Practice::Schema->connect( $dsn, $user, $pass );

my $rule_rs = $schema->resultset( 'PhraseStructureRule' )
  ->search( {}, { prefetch => [ 'target', { 'rule_nodes' => ['cat'] } ] } );

my $rule = {};

# Load the grammar rules in to the $rule hashref
while ( my $r = $rule_rs->next() ) {
  my $tlabel = $r->target->label;
  $rule->{$tlabel} = { rs    => $r,
                       label => $tlabel,
                       node  => [], };
  print STDERR ( "$tlabel ->" );

  my $nodes = $r->rule_nodes;
  while ( my $n = $nodes->next ) {
    my $nlabel = $n->cat->label;
    if ( $n->optional ) {
      if ( $n->rpt ) {
        $nlabel = "$nlabel*";
      } else {
        $nlabel = "($nlabel)";
      }
    } elsif ( $n->rpt ) {
      $nlabel = "$nlabel+";
    }
    my $position = $n->position;
    $rule->{$tlabel}->{node}->[ $position - 1 ] = $n;
    print STDERR ( " $nlabel" );
  }
  print STDERR ( "\n" );
}
print STDERR ( "=====\n" );
my $lexeme_rs = $schema->resultset( 'Lexeme' )->search( {}, { prefetch => ['cat'] } );

my $lexeme = {};
while ( my $l = $lexeme_rs->next() ) {
  $lexeme->{ $l->word } = $l;
}

my $content;

{
  open( my $fh, q{<}, $getOpt->file ) or die "could not open file [" . $getOpt->file . "]";
  $content = join( "", <$fh> );
}

chomp $content;

my @word_list = map { lc $_ } split( /\s+/, $content );

use Data::Dumper;

print STDERR "$content\n=====\n";

# Find phrases licensed when max number of iterations is 5
my $tree = license_phrase(
                           { rule       => $rule->{'S'},
                             word_list  => \@word_list,
                             iterations => 5,
                             max_depth  => 5,
                           } );

if ( ref $tree eq 'HASH' && exists $tree->{error} ) {
  die "parse failure: $tree->{error}";
}

foreach my $t ( denormalize_tree( $tree ) ) {
  print_tree( $t, '' );
}

if ( ref $tree eq 'HASH' && exists $tree->{error} ) {
  print STDERR "$tree->{error}\n";
}

sub license_lexeme {
  my ( $opt ) = @_;

  my $node_label = $opt->{node}->cat->label;
  unless ( @{ $opt->{word_list} } ) {
    return { error => "insufficient words to license lexeme [$node_label]" };
  }

  my $w = shift( @{ $opt->{word_list} } );
  my $l = $lexeme->{$w};

  if ( $l->cat->label eq $opt->{node}->cat->label ) {
    return $l;
  } else {
    unshift( @{ $opt->{word_list} }, $w );
    return ( { error => "lexeme [$w] not licensed by [$node_label]" } );
  }
}

sub node_loop {
  my ( $arg ) = @_;
  my $opt = $arg->{phrase_opt};
  my ( @licensed, @error ) = ( @{ $arg->{licensed} } );

  my @initial_node_list = @{ $arg->{node_list} };
  my @initial_word_list = @{ $opt->{word_list} };

  my $num_nodes = scalar @initial_node_list;

  my @lic = ();
  while ( my $child = shift @{ $arg->{node_list} } ) {
    my @err;
    my $label    = $child->cat->label;
    my $cat_type = $child->cat->ctype;
    my $position = $child->position - 1;    # indexed from 1

    my $num_words = scalar @{ $opt->{word_list} };
    if ( $opt->{iterations} > $num_words ) {
      $opt->{iterations} = $num_words;
    }

    my ( $min_i, $max_i ) = ( 1, $opt->{iterations} );

    if ( $child->optional ) {
      if ( $opt->{iterations} == 0 ) {
        $opt->{iterations} = $num_words;
        next;
      }
      $min_i = 0;
      unless ( $child->rpt ) {
        $max_i = 1;
      }
    } elsif ( $child->rpt ) {
      if ( $child->optional ) {
        $min_i = 0;
      }
    } else {
      $max_i = 1;
    }

    if ( $opt->{iterations} < $min_i ) {
      return ( { error => "cannot iterate $opt->{iterations} times" } );
    }

    my $return;
    my ( $options, $function );
    my $remainder_sub = sub { return @{ $_->{word_list} } };
    if ( $cat_type eq 'phrasal' ) {
      $options = { rule          => $rule->{$label},
                   word_list     => $opt->{word_list},
                   max_depth     => $opt->{max_depth},
                   current_depth => $opt->{current_depth} + 1,
                   iterations    => 1, };
      $function = sub { license_phrase( @_ ) };
    } elsif ( $cat_type eq 'lexical' ) {
      $options = { node      => $child,
                   word_list => $opt->{word_list} };
      $function = sub { license_lexeme( @_ ) };
    } else {
      die( "category [$cat_type] unknown" );
    }
    for ( my $i = $min_i; $i <= $max_i; $i++ ) {
      my @word_list = @{ $options->{word_list} };

      if ( $i == 0 ) {
        push( @lic,
              { remainder  => [@word_list],
                result     => undef,
                iterations => $i,
                cat_type   => $cat_type,
              } );
        next;
      }

      warn "category [$cat_type] has unrecognized CODE ref" unless ref $function eq 'CODE';
      if ( $cat_type eq 'lexical' ) {
        warn "node field not set" unless exists $options->{node} && ref $options->{node};
      }
      my $return    = $function->( $options );
      my @remainder = @{ $options->{word_list} };

      if( scalar @remainder >= scalar @word_list ){
        warn "word list count was not decremented";
      }

      if ( ref $return eq 'HASH' && exists $return->{error} ) {
        $opt->{word_list} = [@word_list];
        last;
      } else {
        push( @lic,
              { remainder  => \@remainder,
                result     => $return,
                iterations => $i,
                cat_type   => $cat_type,
              } );
      }

    }
    if ( @lic ) {
      $licensed[$position] = \@lic;
    } else {
      $opt->{word_list} = [@initial_word_list];
      $opt->{node_list} = [@initial_node_list];
      $licensed[$position] = [];
    }
  }

  my $valid = 1;
  for(my $i = 0; $i <= $num_nodes; $i++){
    if( ref $licensed[$i] ne 'ARRAY' ){
      $valid = 0;
      next;
    }
    if( scalar @{$licensed[$i]} == 0 ){
      $valid = 0;
    }
  }
  if( $valid ){
    return ( \@licensed );
  }else{
    return { error => "Not all nodes are licensed" };
  }
}

sub count_nodes {
  my ( $node_list, $iterations, $current_depth, $max_depth ) = @_;

  my ( $min_nodes, $max_nodes ) = ( 0, 0 );
  if ( $current_depth > $max_depth ) {
    return ( $min_nodes, $max_nodes );
  }
  my $subnode_list = [];
  foreach my $child ( @$node_list ) {
    if ( $child->cat->ctype eq 'lexical' ) {
      if ( $child->rpt ) {
        $max_nodes += $iterations;
      } else {
        $max_nodes++;
      }
      unless ( $child->optional ) {
        $min_nodes++;
      }

    } elsif ( $child->cat->ctype eq 'phrasal' ) {
      my $label = $child->cat->label;
      my ( $min, $max ) = count_nodes( $rule->{$label}->{node}, $iterations, $current_depth + 1, $max_depth );
      $min_nodes += $min;
      $max_nodes += $max;
    }
  }
  return ( $min_nodes, $max_nodes );
}

my $default_max_depth = 5;

sub license_phrase {
  my ( $opt ) = @_;

  my $target_label = $opt->{rule}->{label};

  unless ( exists $opt->{max_depth} ) {
    warn( "max depth not set" );
    $opt->{max_depth} = 0;
  }

  $opt->{current_depth} = 1 unless ( exists $opt->{current_depth} );

  if ( $opt->{current_depth} > $opt->{max_depth} ) {
    return { error => "Depth $opt->{current_depth} is beyond max depth $opt->{max_depth}" };
  }

  my ( $min_nodes, $max_nodes ) =
    count_nodes( $opt->{rule}->{node}, $opt->{iterations}, $opt->{current_depth}, $opt->{max_depth} );
  my $num_words = scalar @{ $opt->{word_list} };

  if ( $min_nodes > $num_words ) {
    return { error => 'insufficient words to license phrase [$target_label]' };
  }

  my @node_list = sort { $a->position > $b->position } @{ $opt->{rule}->{node} };

  my $return = node_loop(
                          { phrase_opt => $opt,
                            min_nodes  => $min_nodes,
                            node_list  => [@node_list],
                            parsed     => [],
                            licensed   => [],
                          } );
  if ( ref $return eq 'HASH' && exists $return->{error} ) {
    return $return;
  }

  return { $target_label => $return };
}

sub dedup_list {
  my ( $first, @rest ) = @_;
  my @uniq = ( $first );
  while ( my $next = shift( @rest ) ) {
    my $is_unique = 1;
    foreach my $u ( @uniq ) {
      if ( Compare( $u, $next ) ) {
        $is_unique = 0;
        last;
      }
    }
    push( @uniq, $next ) if $is_unique;
  }
  return @uniq;
}

sub denormalize_tree {
  my ( $tree ) = @_;

  if ( ref $tree eq 'HASH' && exists $tree->{error} ) {
    warn( "error: $tree->{error}" );
    return;
  }

  my ( $target_label, $nodes ) = ( %$tree );
  die Data::Dumper::Dumper( $tree ) unless $target_label;
  my @tree = ( { $target_label => [] } );

  foreach my $node ( @$nodes ) {
    my @node = @{ $tree[-1]->{$target_label} };

    my $lic = shift( @$node );

    my $licensed = $lic->{result};

    if ( ref $licensed eq 'HASH' && exists $licensed->{error} ) {
      die "error processing nodes: $licensed->{error}";
    } elsif ( ref $licensed eq 'Syntactic::Practice::Schema::Result::Lexeme' ) {
      foreach my $t ( @tree ) {
        push( @{ $t->{$target_label} }, $licensed );
      }
    } elsif ( ref $licensed eq 'HASH' ) {
      my @subtree = denormalize_tree( $licensed );
      my $subtree = shift( @subtree );
      foreach my $t ( @tree ) {
        push( @{ $t->{$target_label} }, $subtree );
      }
      foreach my $subtree ( @subtree ) {
        push( @tree, { $target_label => [ @node, $subtree ] } );
      }
    }

    foreach my $lic ( @$node ) {
      my $licensed = $lic->{result};
      if ( ref $licensed eq 'Syntactic::Practice::Schema::Result::Lexeme' ) {
        push( @tree, { $target_label => [ @node, $licensed ] } );
      } elsif ( ref $licensed eq 'HASH' ) {
        foreach my $subtree ( denormalize_tree( $licensed ) ) {
          push( @tree, { $target_label => [ @node, $subtree ] } );
        }
      }
    }
  }
  return ( dedup_list( @tree ) );
}

sub print_tree {
  my ( $tree, $indent ) = @_;
  my ( $target_label ) = ( keys %$tree );
  print STDERR "${indent}${target_label} { \n";

  foreach my $licensed ( @{ $tree->{$target_label} } ) {
    if ( ref $licensed eq 'HASH' ) {
      print_tree( $licensed, "${indent}  " );
    } else {
      my $word  = $licensed->word;
      my $label = $licensed->cat->label;
      print STDERR "${indent}  $label $word\n";
    }
  }
  print STDERR "${indent}}\n";
}

