#!/usr/bin/perl

use strict;
use warnings;

use Getopt::Long::Descriptive;
use DBI;
use Data::Compare;

# TODO: variable glossary

my $hostname = 'localhost';
my $port     = '3306';
my $database = 'grammar';
my $user     = 'grammaruser';
my $pass     = 'nunya';
my $dsn      = "DBI:mysql:database=$database;host=$hostname;port=$port";

my ( $getOpt, $usage ) =
  describe_options( 'parse %o <some-arg>',
                    [ 'file|f=s', "file containing text to parse", { required => 1 } ],
                    [],
                    [ 'verbose|v', "print extra stuff" ],
                    [ 'help',      "print usage message and exit" ], );

print( $usage->text ), exit if $getOpt->help;

use Syntactic::Practice::Schema;
my $schema = Syntactic::Practice::Schema->connect( $dsn, $user, $pass );

my $rule_rs = $schema->resultset( 'PhraseStructureRule' )
  ->search( {}, { prefetch => [ 'target', { 'rule_nodes' => ['cat'] } ] } );

my $rule = {};

# Load the grammar rules in to the $rule hashref
while ( my $r = $rule_rs->next() ) {
  my $tlabel = $r->target->label;
  $rule->{$tlabel} = { rs    => $r,
                       label => $tlabel,
                       node  => [], };
  print STDERR ( "$tlabel ->" );

  my $nodes = $r->rule_nodes;
  while ( my $n = $nodes->next ) {
    my $nlabel = $n->cat->label;
    if ( $n->optional ) {
      if ( $n->rpt ) {
        $nlabel = "$nlabel*";
      } else {
        $nlabel = "($nlabel)";
      }
    } elsif ( $n->rpt ) {
      $nlabel = "$nlabel+";
    }
    my $position = $n->position;
    $rule->{$tlabel}->{node}->[ $position - 1 ] = $n;
    print STDERR ( " $nlabel" );
  }
  print STDERR ( "\n" );
}
print STDERR ( "=====\n" );
my $lexeme_rs = $schema->resultset( 'Lexeme' )->search( {}, { prefetch => ['cat'] } );

my $lexeme = {};
while ( my $l = $lexeme_rs->next() ) {
  $lexeme->{ $l->word } = $l;
}

my $content;

{
  open( my $fh, q{<}, $getOpt->file ) or die "could not open file [" . $getOpt->file . "]";
  $content = join( "", <$fh> );
}

chomp $content;

my @word_list = map { lc $_ } split( /\s+/, $content );

use Data::Dumper;

print STDERR "$content\n=====\n";

# Find phrases licensed when max number of iterations is 5
my $tree = license_phrase(
                           { rule       => $rule->{'S'},
                             word_list  => \@word_list,
                             iterations => 5,
                             max_depth  => 5,
                           } );

if ( ref $tree eq 'HASH' && exists $tree->{error} ) {
  die "parse failure: $tree->{error}";
}

foreach my $t ( denormalize_tree( $tree ) ) {
  print_tree( $t, '' );
}

if ( ref $tree eq 'HASH' && exists $tree->{error} ) {
  print STDERR "$tree->{error}\n";
}

sub license_lexeme {
  my ( $opt ) = @_;

  my $node_label = $opt->{node}->cat->label;
  unless ( @{ $opt->{word_list} } ) {
    return { error => "insufficient words to license lexeme [$node_label]" };
  }

  my $w = shift( @{ $opt->{word_list} } );
  my $l = $lexeme->{$w};

  if ( $l->cat->label eq $opt->{node}->cat->label ) {
    return $l;
  } else {
    unshift( @{ $opt->{word_list} }, $w );
    return ( { error => "lexeme [$w] not licensed by [$node_label]" } );
  }
}

sub node_loop {
  my ( $arg ) = @_;
  my $opt = $arg->{phrase_opt};
  my ( @licensed, @error ) = ( @{ $arg->{licensed} } );

  my @initial_node_list  = @{ $arg->{node_list} };
  my @initial_word_list  = @{ $opt->{word_list} };
  my $initial_iterations = $opt->{iterations};

  my $num_nodes = scalar @initial_node_list;

  my $indent = ' ' x ( $opt->{current_depth} - 1 );
  print STDERR "${indent}Attempting to license $opt->{rule}->{label}\n";

  my $position = 0;
  my @initial_set = ( { remainder => [@initial_word_list] } );
  while ( my $child = shift @{ $arg->{node_list} } ) {

    my $label    = $child->cat->label;
    my $cat_type = $child->cat->ctype;
    if ( $child->position - 1 != $position ) {    # indexed from 1
      die "something is wrong.  node position is not as expected.";
    }
    my $set;
    if ( $position == 0 ) {
      $set = [
               { remainder  => [@initial_word_list],
                 result     => undef,
                 iterations => undef,
                 node       => undef,
                 position   => undef,
                 precursor  => undef,
               } ];
    } else {
      $set = $licensed[ $position - 1 ];    # the nodes licensed by the previous pass
      $licensed[ $position - 1 ] = [];
    }
    while ( my $lic = shift @$set ) {
      $opt->{word_list} = $lic->{remainder};

      my $num_words = scalar @{ $opt->{word_list} };
      if ( $opt->{iterations} > $num_words ) {
        $opt->{iterations} = $num_words;
      }

      my ( $min_i, $max_i );
      my $nlabel = $label;
      if ( $child->optional ) {
        $min_i = 0;
        if ( $child->rpt ) {
          $nlabel = "$nlabel*";
          $max_i  = $opt->{iterations};
        } else {
          $nlabel = "($nlabel)";
          $max_i  = 1;
        }
      } elsif ( $child->rpt ) {
        $min_i  = 1;
        $max_i  = $opt->{iterations};
        $nlabel = "$nlabel+";
      } else {
        $min_i = 1;
        $max_i = 1;
      }

      if ( $opt->{iterations} < $min_i ) {
        return ( { error => "cannot iterate $opt->{iterations} times" } );
      }

      my ( $options, $function );
      my $remainder_sub = sub { return @{ $_->{word_list} } };
      my $wl = [ @{ $opt->{word_list} } ];
      if ( $cat_type eq 'phrasal' ) {
        $options = { rule          => $rule->{$label},
                     word_list     => $wl,
                     max_depth     => $opt->{max_depth},
                     current_depth => $opt->{current_depth} + 1,
                     iterations    => $opt->{iterations}, };
        $function = sub {
          my ( $opt ) = @_;
          my $tree = license_phrase( $opt );
          return [ denormalize_tree( $tree, "FULL" ) ];
        };
      } elsif ( $cat_type eq 'lexical' ) {
        $options = { node      => $child,
                     word_list => $wl };
        $function = sub { license_lexeme( @_ ) };
      } else {
        die( "category [$cat_type] unknown" );
      }
      my @lic = ();

      print STDERR (
            "${indent}attempting $max_i time(s) to license ($cat_type) $nlabel with words [@{$lic->{remainder}}]\n" );
      for ( my $i = $min_i; $i <= $max_i; $i++ ) {
        my @word_list = @{ $opt->{word_list} };
        my @r         = ();

        my @r_word = ( [@word_list] );
        while ( my $rwl = shift( @r_word ) ) {
          for ( my $n = 1; $n <= $i; $n++ ) {
            my $return = $function->( $options );

            if ( ref $return eq 'HASH' && exists $return->{error} ) {
              $#{$wl} = -1;
              push( @$wl, @{ $opt->{word_list} } );
              last;
            } elsif ( $cat_type eq 'phrasal' ) {
              foreach my $tree ( @$return ) {
                push( @r_word, [ @{ $tree->{remainder} } ] );
              }
            }

            push( @r, $return );
          }
          if ( scalar @r == $i ) {
            my @r_word = @{ $options->{word_list} };
            if ( $i > 0 && scalar @r_word >= scalar @word_list ) {
              warn "word list count was not decremented";
            }

            push( @lic,
                  { remainder  => \@r_word,
                    result     => \@r,
                    iterations => $i,
                    node       => $child,
                    position   => $position,
                    precursor  => $lic,
                  } );
          }
          $#{$wl} = -1;
          push( @$wl, @{ $opt->{word_list} } );
        }
        if ( @lic ) {
          my $count = scalar @lic;
          print STDERR "${indent}$nlabel successfully licensed ($count matches):\n";
          foreach my $l ( @lic ) {
            print STDERR "${indent}  $l->{iterations} iteration(s) with remaining words: [@{ $l->{remainder} }]\n";
          }
          push( @{ $licensed[$position] }, @lic );

          # if any nodes have been licensed, place precursor back on
          # list of licensed nodes
          push( @{ $licensed[ $position - 1 ] }, $lic );
        } else {
          print STDERR "${indent}failed to license $nlabel with words [ @{$lic->{remainder}} ]\n";
        }
      }
    }
    $position++;
  }

  my $valid = 1;
  for ( my $i = 0; $i < $num_nodes; $i++ ) {
    my $node = $initial_node_list[$i];
    if ( ref $licensed[$i] ne 'ARRAY' ) {
      $valid = 0;
      return {   error => "List of parses at position $i ("
               . $node->cat->label
               . ") in rule $opt->{rule}->{label} not an array" };
    }
    if ( scalar @{ $licensed[$i] } == 0 ) {
      $valid = 0;
      return { error => "Node number $i in rule $opt->{rule}->{label} not licensed" };
    }
  }
  if ( $valid ) {
    return ( \@licensed );
  } else {
    print STDERR "${indent}Not all nodes in rule $opt->{rule}->{label} are licensed\n";
    return { error => "Not all nodes in rule $opt->{rule}->{label} are licensed" };
  }
}

sub count_nodes {
  my ( $node_list, $iterations, $current_depth, $max_depth ) = @_;

  my ( $min_nodes, $max_nodes ) = ( 0, 0 );
  if ( $current_depth > $max_depth ) {
    return ( $min_nodes, $max_nodes );
  }
  my $subnode_list = [];
  foreach my $child ( @$node_list ) {
    if ( $child->cat->ctype eq 'lexical' ) {
      if ( $child->rpt ) {
        $max_nodes += $iterations;
      } else {
        $max_nodes++;
      }
      unless ( $child->optional ) {
        $min_nodes++;
      }

    } elsif ( $child->cat->ctype eq 'phrasal' ) {
      my $label = $child->cat->label;
      my ( $min, $max ) = count_nodes( $rule->{$label}->{node}, $iterations, $current_depth + 1, $max_depth );
      $min_nodes += $min;
      $max_nodes += $max;
    }
  }
  return ( $min_nodes, $max_nodes );
}

my $default_max_depth = 5;

sub license_phrase {
  my ( $opt ) = @_;

  my $target_label = $opt->{rule}->{label};

  unless ( exists $opt->{max_depth} ) {
    warn( "max depth not set" );
    $opt->{max_depth} = 0;
  }

  $opt->{current_depth} = 1 unless ( exists $opt->{current_depth} );

  if ( $opt->{current_depth} > $opt->{max_depth} ) {
    return { error => "Depth $opt->{current_depth} is beyond max depth $opt->{max_depth}" };
  }

  my ( $min_nodes, $max_nodes ) =
    count_nodes( $opt->{rule}->{node}, $opt->{iterations}, $opt->{current_depth}, $opt->{max_depth} );
  my $num_words = scalar @{ $opt->{word_list} };

  if ( $min_nodes > $num_words ) {
    return { error => 'insufficient words to license phrase [$target_label]' };
  }

  my @node_list = sort { $a->position > $b->position } @{ $opt->{rule}->{node} };

  my $return = node_loop(
                          { phrase_opt => $opt,
                            min_nodes  => $min_nodes,
                            node_list  => [@node_list],
                            parsed     => [],
                            licensed   => [],
                          } );
  if ( ref $return eq 'HASH' && exists $return->{error} ) {
    return $return;
  }

  return { $target_label => $return };
}

sub dedup_list {
  my ( $first, @rest ) = @_;
  my @uniq = ( $first );
  while ( my $next = shift( @rest ) ) {
    my $is_unique = 1;
    foreach my $u ( @uniq ) {
      if ( Compare( $u, $next ) ) {
        $is_unique = 0;
        last;
      }
    }
    push( @uniq, $next ) if $is_unique;
  }
  return @uniq;
}

sub denormalize_tree {
  my ( $tree, $full ) = @_;

  if ( ref $tree eq 'HASH' && exists $tree->{error} ) {
    warn( "error: $tree->{error}" );
    return;
  }

  my ( $target_label, $nodes ) = ( %$tree );
  die Data::Dumper::Dumper( $tree ) unless $target_label;
  my @tree = ( { $target_label => [] } );

  foreach my $node ( @$nodes ) {
    my @node = @{ $tree[-1]->{$target_label} };

    my $lic = shift( @$node );

    my $result = $lic->{result};
    my $licensed;
    if ( $full ) {
      $licensed = $lic;
    } else {
      $licensed = $result;
    }

    if ( ref $result eq 'HASH' && exists $result->{error} ) {
      die "error processing nodes: $result->{error}";
    } elsif ( ref $result eq 'Syntactic::Practice::Schema::Result::Lexeme' ) {
      foreach my $t ( @tree ) {
        push( @{ $t->{$target_label} }, $licensed );
      }
    } elsif ( ref $result eq 'HASH' ) {
      my @subtree = denormalize_tree( $result, $full );
      my $subtree = shift( @subtree );
      foreach my $t ( @tree ) {
        push( @{ $t->{$target_label} }, $subtree );
      }
      foreach my $subtree ( @subtree ) {
        push( @tree, { $target_label => [ @node, $subtree ] } );
      }
    } elsif ( ref $result eq 'ARRAY' ) {
      my @subtree = @$result;
      my $subtree = shift( @subtree );
      foreach my $t ( @tree ) {
        push( @{ $t->{$target_label} }, $subtree );
      }
      foreach my $subtree ( @subtree ) {
        push( @tree, { $target_label => [ @node, $subtree ] } );
      }
    }

    foreach my $lic ( @$node ) {
      my $result = $lic->{result};
      my $licensed;
      if ( $full ) {
        $licensed = $lic;
      } else {
        $licensed = $result;
      }
      if ( ref $result eq 'HASH' && exists $result->{error} ) {
        die "error processing nodes: $result->{error}";
      } elsif ( ref $result eq 'Syntactic::Practice::Schema::Result::Lexeme' ) {
        push( @tree, { $target_label => [ @node, $licensed ] } );
      } elsif ( ref $result eq 'HASH' ) {
        foreach my $subtree ( denormalize_tree( $result, $full ) ) {
          push( @tree, { $target_label => [ @node, $subtree ] } );
        }
      } elsif ( ref $result eq 'ARRAY' ) {
        my @subtree = @$result;
        my $subtree = shift( @subtree );
        foreach my $t ( @tree ) {
          push( @{ $t->{$target_label} }, $subtree );
        }
        foreach my $subtree ( @subtree ) {
          push( @tree, { $target_label => [ @node, $subtree ] } );
        }
      }
    }
  }
  my @dedup_tree = dedup_list( @tree );
  my @return;
  if ( $full ) {
    foreach my $t ( @dedup_tree ) {
      my ( $lbl, $nlist ) = %$t;
      my @rword = @{ $nlist->[-1]->{remainder} };
      push( @return,
            { result    => $t,
              remainder => @rword,
            } );
    }
  } else {
    @return = @dedup_tree;
  }
  return ( @return );
}

sub print_tree {
  my ( $tree, $indent ) = @_;
  my ( $target_label ) = ( keys %$tree );
  print STDERR "${indent}${target_label} { \n";

  foreach my $licensed ( @{ $tree->{$target_label} } ) {
    if ( ref $licensed eq 'HASH' ) {
      print_tree( $licensed, "${indent}  " );
    } else {
      my $word  = $licensed->word;
      my $label = $licensed->cat->label;
      print STDERR "${indent}  $label $word\n";
    }
  }
  print STDERR "${indent}}\n";
}

