#!/usr/bin/perl

use strict;
use warnings;

use Getopt::Long::Descriptive;
use DBI;

my $hostname = 'localhost';
my $port     = '3306';
my $database = 'grammar';
my $user     = 'grammaruser';
my $pass     = 'nunya';
my $dsn      = "DBI:mysql:database=$database;host=$hostname;port=$port";
my $dbh      = DBI->connect($dsn, $user, $pass);

my $input;
my $verbose;

my ($opt, $usage) =
  describe_options(
                   'parse %o <some-arg>',
                   [ 'file|f=s', "file containing text to parse", { required => 1  } ],
                   [],
                   [ 'verbose|v',  "print extra stuff"            ],
                   [ 'help',       "print usage message and exit" ],
                  );

print($usage->text), exit if $opt->help;

my $query =
  {
   word =>
     'SELECT l.id, l.word, c.label, c.longname
        FROM lexeme l LEFT JOIN lexical_category c ON l.cat_id=c.id',
   rule =>
     'SELECT r.id, r.node_count, c.label, c.longname, c.head
        FROM phrase_structure_rule r LEFT JOIN phrasal_category c ON r.target_id=c.id',
   rule_node =>
     'SELECT n.id, n.rule_id, n.position,
             c.ctype, c.label, c.longname, BIN(n.optional), BIN(n.rpt)
        FROM rule_node n LEFT JOIN syntactic_category c ON n.cat_id=c.id WHERE n.rule_id=?
      ORDER BY n.position',
  };

my $sth = {};
while( my($k,$q) = each %$query ){
  $sth->{$k} = $dbh->prepare( $q );
}

$sth->{rule}->execute();

use Syntactic::Practice::Schema;
my $schema = Syntactic::Practice::Schema->connect($dsn, $user, $pass);

my $rule_rs = $schema->resultset('PhraseStructureRule')->
  search({},
         {
          prefetch   => ['target', { 'rule_nodes' => ['cat'] } ]
         });

#SELECT r.id, r.node_count, c.label, c.longname, c.head
#        FROM phrase_structure_rule r LEFT JOIN phrasal_category c ON r.target_id=c.id

my $rule = {};
# Load the rules in to the $rule hashref
while( my $r = $rule_rs->next() ){
  my $tlabel = $r->target->label;
  $rule->{$tlabel} =
    { rs => $r,
      label => $tlabel,
      node => [],
    };
#  print("Processing rule for target [$tlabel]\n");
  my $nodes = $r->rule_nodes;
  while( my $n = $nodes->next ){
    my $nlabel = $n->cat->label;
    my $position = $n->position;
#    print("  Node #$position: $nlabel\n");
    $rule->{$tlabel}->{node}->[$position - 1] = $n;
  }
}

my $lexeme_rs = $schema->resultset('Lexeme')->
  search({},{prefetch => ['cat'] });

my $lexeme = {};
while( my $l = $lexeme_rs->next() ){
  $lexeme->{$l->word} = $l;
}

my $content;

{
  open( my $fh, q{<}, $opt->file ) or die "could not open file [" . $opt->file . "]";
  $content = join("", <$fh>);
}

my @word_list = map { lc $_ } split(/\s+/, $content);

#use Data::Dumper;
#die Data::Dumper::Dumper( $rule->{'S'} );

use Data::Dumper;
#die Data::Dumper::Dumper( @word_list );
my $min_nodes = 0;
my $trees = license_phrase( {
                             rule      => $rule->{'S'},
                             word_list => \@word_list,
                             min_nodes => 0,
                             minimal   => 0,
                            } );

if( ref $trees eq 'HASH' && exists $trees->{error} ){
  print STDERR "$trees->{error}\n";
}

# TODO: Traverse phrase_structure_rule depth first and begin inserting
# leaf nodes in to the tree

sub is_lexeme_licensed {
  my ( $w, $n ) = @_;
  return 1 if( $lexeme->{$w}->cat->label eq $n->cat->label );
  return 0;
}

sub license_lexeme {
  my( $opt ) = @_;

  my $node_label = $opt->{node}->cat->label;
  unless( @{ $opt->{word_list} } ){
    return {error => "insufficient words to license lexeme [$node_label]"};
  }

  my @licensed = ();
  my $w = shift( @{ $opt->{word_list} } );
  my $l = $lexeme->{$w};

  if($opt->{node}->optional){
    if( $opt->{minimal} ){
      return @licensed;
    }
  }

  if( is_lexeme_licensed( $w, $opt->{node} ) ){
    push(@licensed, $l);
    print STDERR "$node_label $w\n";
  }else{
    unshift( @{ $opt->{word_list} }, $w );
    return({ error => "lexeme [$w] not licensed by [$node_label]" });
  }
  return @licensed;
}

sub node_loop {
  my( $arg ) = @_;
  my $opt = $arg->{phrase_opt};
  my( $tree, @alt_tree );

  while( my $child = shift @{ $arg->{node_list} } ){
    my $label = $child->cat->label;
    my $cat_type = $child->cat->ctype;

    if($child->optional){
      next if( $opt->{minimal} );
      # This will potentially produce a new parse tree.
      if( $cat_type eq 'phrasal' ){
        my $return = license_phrase( { rule      => $opt->{rule},
                                       word_list => [ @{$opt->{word_list}} ],
                                       min_nodes => $opt->{min_nodes},
                                       minimal   => 1, } );
        if( ref $return eq 'HASH' && exists $return->{error} ){
          # Parse failed with minimal set
        }else{
          # Parse succeeded.  Add to alternate parse tree list
          push( @alt_tree, @$return );
        }
      }elsif( $cat_type eq 'lexical' ){
        my $return = node_loop( {
                                 phrase_opt => {
                                                rule      => $opt->{rule},
                                                word_list => [ @{$opt->{word_list}} ],
                                                min_nodes => $opt->{min_nodes},
                                                minimal   => 1,
                                               },
                                 node_list  => [ $child, @{ $arg->{node_list} } ],
                                 parsed     => [ @{ $arg->{parsed} } ],
                                 licensed   => [ @{ $arg->{licensed} } ],
                                 minimal    => 1
                                } );
        if( ref $return eq 'HASH' && exists $return->{error} ){
          # Parse failed with minimal set
        }else{
          # Parse succeeded.  Add to alternate parse tree list
          push( @alt_tree, { $opt->{rule}->{label} => $return->{licensed} } );
        }
      }
    }

    my $num_iterations = 1;
    if( $child->rpt ){
      $num_iterations = 0;
      # TODO: we need a way to create a tree for variable number of
      # iterations, not just min and max

      foreach my $lbl ( map { $lexeme->{$_}->cat->label } @{ $opt->{word_list} } ){
        if( $lbl eq $label ){
          $num_iterations++
        }else{
          last;
        }
      }
    }

    for( my $i = 0; $i < $num_iterations; $i++ ){
      my $return;
      if( $cat_type eq 'phrasal' ){
        $return = license_phrase( { rule      => $rule->{$label},
                                    word_list => $opt->{word_list},
                                    min_nodes => $opt->{min_nodes},
                                    minimal   => 0,
                                  } );
      }elsif($cat_type eq 'lexical'){
        $return = license_lexeme( { node      => $child,
                                    word_list => $opt->{word_list},
                                    minimal   => $arg->{minimal},
                                  } );
      }

      if( ref $return eq 'HASH' && exists $return->{error} ){
        if( @alt_tree ){
          return \@alt_tree;
        }else{
          return $return;
        }
      }else{
        push( @{ $arg->{licensed} }, $return );
      }
    }
    push(@{ $arg->{parsed} }, $child);
    $opt->{minimal} = $arg->{minimal} = 0;
  }

  return( [ { $opt->{rule}->{label} => $arg->{licensed} },
            @alt_tree ] );
}

sub license_phrase {
  my( $opt ) = @_;

  my $target_label = $opt->{rule}->{label};
  print STDERR "$target_label\n";

  # count nodes
  # subtract optional
  my $min_nodes = $opt->{min_nodes};
  my $num_optional_nodes = scalar grep { $_->optional } @{$opt->{rule}->{node}};
  $min_nodes += ( scalar @{$opt->{rule}->{node}} - $num_optional_nodes );

  if( $min_nodes > scalar @{$opt->{word_list}} ){
    return {error => 'insufficient words to license phrase [$target_label]'};
  }

  my $return = node_loop( { phrase_opt => $opt,
                            min_nodes  => $min_nodes,
                            node_list  => $opt->{rule}->{node},
                            parsed     => [],
                            licensed   => [],
                          } );

  return $return;
}
