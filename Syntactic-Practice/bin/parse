#!/usr/bin/perl

use strict;
use warnings;
use Carp;

use Getopt::Long::Descriptive;
use DBI;
use Data::Compare;

use Syntactic::Practice::Parser::Constituent;
use Syntactic::Practice::Schema;

# TODO: variable glossary

my $hostname = 'localhost';
my $port     = '3306';
my $database = 'grammar';
my $user     = 'grammaruser';
my $pass     = 'nunya';
my $dsn      = "DBI:mysql:database=$database;host=$hostname;port=$port";

my ( $getOpt, $usage ) =
  describe_options( 'parse %o <some-arg>',
                    [ 'file|f=s', "file containing text to parse", { required => 1 } ],
                    [],
                    [ 'verbose|v', "print extra stuff" ],
                    [ 'help',      "print usage message and exit" ], );

print( $usage->text ), exit if $getOpt->help;

my $schema = Syntactic::Practice::Schema->connect( $dsn, $user, $pass );

my $rule_rs = $schema->resultset( 'PhraseStructureRule' )
  ->search( {}, { prefetch => [ 'target', { 'rule_nodes' => ['cat'] } ] } );

my $rule = {};

my $constByLabel = {};

# Load the grammar rules in to the $rule hashref
while ( my $r = $rule_rs->next() ) {
  my $tlabel = $r->target->label;
  $rule->{$tlabel} = { rs    => $r,
                       label => $tlabel,
                       node  => [], };
  print STDERR ( "$tlabel ->" );

  my $nodes = $r->rule_nodes;
  while ( my $n = $nodes->next ) {
    my $nlabel = $n->cat->label;
    if ( $n->optional ) {
      if ( $n->rpt ) {
        $nlabel = "$nlabel*";
      } else {
        $nlabel = "($nlabel)";
      }
    } elsif ( $n->rpt ) {
      $nlabel = "$nlabel+";
    }
    my $position = $n->position;
    $rule->{$tlabel}->{node}->[ $position - 1 ] = $n;
    print STDERR ( " $nlabel" );
  }
  print STDERR ( "\n" );
}
print STDERR ( "=====\n" );
my $lexeme_rs = $schema->resultset( 'Lexeme' )->search( {}, { prefetch => ['cat'] } );

my $lexeme = {};
while ( my $l = $lexeme_rs->next() ) {
  $lexeme->{ $l->word } = $l;
}

my $content;

{
  open( my $fh, q{<}, $getOpt->file ) or die "could not open file [" . $getOpt->file . "]";
  $content = join( "", <$fh> );
}

chomp $content;

my @word_list = map { lc $_ } split( /\s+/, $content );

use Data::Dumper;

print STDERR "$content\n=====\n";

my @constituents = license_phrasal_rule( \@word_list, 0, $rule->{S}, 5, 0 );

foreach my $c ( @constituents ) {
  print_tree( $c );
}

sub license_lexical_rule {
  my ( $sentence, $from, $lexical_rule ) = @_;

  my $num_words = scalar( @$sentence );
  confess( "invalid sentence ($num_words): [ @$sentence ]" ) if grep { !defined $_ } @$sentence;
  return ( { error => "insufficient words to license additional lexical rule" } )
    if ( $from >= $num_words );

  my $target_label = $lexical_rule->cat->label;
  my $const_list   = [];
  if ( exists $constByLabel->{$target_label} ) {
    $const_list = $constByLabel->{$target_label};
  } else {
    $constByLabel->{$target_label} = $const_list;
  }

  my $num = scalar @$const_list;

  my %const_args = ( name          => "${target_label}${num}",
                     label         => $target_label,
                     decomposition => [],
                     sentence      => $sentence,
                     frompos       => $from,
                     topos         => $from + 1,
                     cat_type      => 'lexical', );

  my $word         = $sentence->[$from];
  my $l            = $lexeme->{$word};
  my $lexeme_label = $l->cat->label;

  if ( $lexeme_label ne $target_label ) {
    return ( { error => "[$word] (position [$from]) with label [$lexeme_label] not licensed by [$target_label]" } );
  }

  my $constituent = Syntactic::Practice::Parser::Constituent->new( %const_args );
  push( @$const_list, $constituent );

  return $constituent;
}

sub license_phrasal_rule {
  my ( $sentence, $from, $phrasal_rule, $max_depth, $current_depth ) = @_;
  confess( "bad phrase rule!" ) unless $phrasal_rule;
  return ( { error => "exceeded maximum recursion depth ($max_depth)" } ) if ( $current_depth > $max_depth );

  my $num_words = scalar( @$sentence );
  return ( { error => "insufficient words to license phrase" } )
    if ( $from >= $num_words );

  my $target_label = $phrasal_rule->{label};

  confess( "invalid sentence ($num_words): [ @$sentence ]" ) if grep { !defined $_ } @$sentence;
  my $s = join( ' ', @$sentence );

  confess(
           Data::Dumper::Dumper(
                                 { sentence         => $sentence,
                                   current_position => $from,
                                   cat_type         => $phrasal_rule->{rs}->target->ctype,
                                   target_label     => $phrasal_rule->{label},
                                   max_depth        => $max_depth,
                                   current_depth    => $current_depth,
                                 }
           )
  ) unless exists $phrasal_rule->{node} && defined $phrasal_rule->{node};

  my @node_list = @{ $phrasal_rule->{node} };

  my $num_nodes = scalar @node_list;

  my @error = ();

  my $method = { lexical => \&license_lexical_rule,
                 phrasal => \&license_phrasal_rule, };

  my @decomp = ( [] );
  for ( my $node_num = 0; $node_num < $num_nodes; $node_num++ ) {
    my $node       = $node_list[$node_num];
    my $node_label = $node->cat->label;
    my $cat_type   = $node->cat->ctype;

    my $r;
    if ( $cat_type eq 'phrasal' ) {
      $r = $rule->{$node_label};
    } elsif ( $cat_type eq 'lexical' ) {
      $r = $node;
    }

    my @arg = ( $sentence, $from, $r, $max_depth, $current_depth + 1 );

    my $optional   = $node->optional;
    my $repeat     = $node->rpt;
    my $const_list = [];
    if ( exists $constByLabel->{$node_label} ) {
      $const_list = $constByLabel->{$node_label};
    } else {
      $constByLabel->{$node_label} = $const_list;
    }

    my $optAtPos = {};

    my $decomp_num = 0;
    while ( $decomp_num < scalar @decomp ) {
      my $decomp = $decomp[$decomp_num];

      next unless ref $decomp eq 'ARRAY';
      my $curpos = $from;

      $curpos = $decomp->[-1]->topos if scalar @$decomp;

      if ( $curpos == $num_words ) {

        # Yay!  We're done!  This decomposition rocks!
        $decomp_num++;
        next;
      }

      $arg[1] = $curpos;

      my @decomp_copy = @$decomp;

      if ( $optional && !exists $optAtPos->{$curpos} ) {
        my $num = scalar @$const_list;
        my $constituent =
          Syntactic::Practice::Parser::Constituent->new( name          => "${node_label}${num}",
                                                         label         => $node_label,
                                                         sentence      => $sentence,
                                                         frompos       => $curpos,
                                                         topos         => $curpos,
                                                         cat_type      => $cat_type,
                                                         decomposition => [], );

        $optAtPos->{$curpos} = $constituent;
        push( @$const_list, $constituent );
        splice( @decomp, $decomp_num++, 0, [ @decomp_copy, $constituent ] );
      }

      my ( @result ) = $method->{$cat_type}->( @arg );

      # remove placeholder ; replaced below unless there is an error
      splice( @decomp, $decomp_num, 1 );

      if ( ref $result[0] eq 'HASH' && exists $result[0]->{error} ) {
        push( @error, $result[0] );
        next;
      }

      foreach my $d ( @result ) {
        splice( @decomp, $decomp_num, 0, [ @decomp_copy, $d ] );
        splice( @decomp, $decomp_num, 0, [ @decomp_copy, $d ] ) if ( $repeat );
      }
      $decomp_num++;
    }
  }

  my $const_list = [];
  if ( exists $constByLabel->{$target_label} ) {
    $const_list = $constByLabel->{$target_label};
  } else {
    $constByLabel->{$target_label} = $const_list;
  }

  my @return = ();
  while ( my $d = shift( @decomp ) ) {
    my $num = scalar @$const_list;
    my %const_args = ( label         => $target_label,
                       sentence      => $sentence,
                       frompos       => $from,
                       cat_type      => 'phrasal',
                       name          => "${target_label}${num}",
                       topos         => $d->[-1]->topos,
                       decomposition => $d );

    my $constituent = Syntactic::Practice::Parser::Constituent->new( %const_args );

    push( @$const_list, $constituent );
    push( @return,      $constituent );
  }

  return @return if scalar @return;
  return @error;
}

sub print_tree {
  my ( $constituent, $depth ) = @_;
  $depth = 0 unless $depth;
  my $indent = " " x ( $depth * 2 );
  print( $indent, $constituent->name, "\n" ) unless $depth > 0;
  foreach my $d ( @{ $constituent->decomposition } ) {
    if ( $d->frompos == $d->topos ) {
      next;
    }
    my @word = ( @{ $constituent->sentence } )[ $d->frompos .. $d->topos - 1 ];
    print( $indent, $d->name, ": @word\n" );
    if ( $d->cat_type eq 'phrasal' ) {
      print_tree( $d, $depth + 1 );
    }
  }
}

