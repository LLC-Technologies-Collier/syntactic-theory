#!/usr/bin/perl

use strict;
use warnings;
use Carp;

use Getopt::Long::Descriptive;
use DBI;

use Syntactic::Practice::Parser::Constituent;
use Syntactic::Practice::Schema;

# TODO: variable glossary

my $hostname = 'localhost';
my $port     = '3306';
my $database = 'grammar';
my $user     = 'grammaruser';
my $pass     = 'nunya';
my $dsn      = "DBI:mysql:database=$database;host=$hostname;port=$port";

my ( $getOpt, $usage ) =
  describe_options( 'parse %o <some-arg>',
                    [ 'file|f=s', "file containing text to parse", { required => 1 } ],
                    [],
                    [ 'verbose|v', "print extra stuff" ],
                    [ 'help',      "print usage message and exit" ], );

print( $usage->text ), exit if $getOpt->help;

my $schema = Syntactic::Practice::Schema->connect( $dsn, $user, $pass );

my $rule_rs = $schema->resultset( 'PhraseStructureRule' )
  ->search( {}, { prefetch => [ 'target', { 'rule_nodes' => ['cat'] } ] } );

my $rule = {};

my $constByLabel = {};

# Load the grammar rules in to the $rule hashref
while ( my $r = $rule_rs->next() ) {
  my $tlabel = $r->target->label;
  $rule->{$tlabel} = { rs    => $r,
                       label => $tlabel,
                       node  => [], };
  print STDERR ( "$tlabel ->" );

  my $nodes = $r->rule_nodes;
  while ( my $n = $nodes->next ) {
    my $nlabel = $n->cat->label;
    if ( $n->optional ) {
      if ( $n->rpt ) {
        $nlabel = "$nlabel*";
      } else {
        $nlabel = "($nlabel)";
      }
    } elsif ( $n->rpt ) {
      $nlabel = "$nlabel+";
    }
    my $position = $n->position;
    $rule->{$tlabel}->{node}->[ $position - 1 ] = $n;
    print STDERR ( " $nlabel" );
  }
  print STDERR ( "\n" );
}
print STDERR ( "=====\n" );
my $lexeme_rs = $schema->resultset( 'Lexeme' )->search( {}, { prefetch => ['cat'] } );

my $lexeme = {};
while ( my $l = $lexeme_rs->next() ) {
  $lexeme->{ $l->word } = $l;
}

my $content = do {
  local undef $/;
  open( my $fh, q{<}, $getOpt->file ) or die "could not open file [" . $getOpt->file . "]";
  <$fh>
};

chomp $content;

my @word_list = map { lc $_ } split( /\s+/, $content );

print STDERR "$content\n=====\n";

my @constituents = license_phrasal_rule( \@word_list, 0, $rule->{S}, 5, 0 );

foreach my $c ( @constituents ) {
  print_tree( $c );
}

sub license_lexical_rule {
  my ( $sentence, $from, $lexical_rule ) = @_;

  my $num_words = scalar( @$sentence );
  return ( { error => "insufficient words to license additional lexical rule" } )
    if ( $from >= $num_words );

  my $target_label = $lexical_rule->cat->label;
  my $const_list   = [];
  if ( exists $constByLabel->{$target_label} ) {
    $const_list = $constByLabel->{$target_label};
  } else {
    $constByLabel->{$target_label} = $const_list;
  }

  my $num = scalar @$const_list;

  my $word         = $sentence->[$from];
  my $l            = $lexeme->{$word};
  my $lexeme_label = $l->cat->label;

  if ( $lexeme_label ne $target_label ) {
    return ( { error => "[$word] (position [$from]) with label [$lexeme_label] not licensed by [$target_label]" } );
  }

  my $constituent =
    Syntactic::Practice::Parser::Constituent->new( name          => "${target_label}${num}",
                                                   label         => $target_label,
                                                   decomposition => [],
                                                   sentence      => $sentence,
                                                   frompos       => $from,
                                                   topos         => $from + 1,
                                                   cat_type      => 'lexical' );
  push( @$const_list, $constituent );

  return $constituent;
}

sub license_phrasal_rule {
  my ( $sentence, $from, $phrasal_rule, $max_depth, $current_depth ) = @_;
  confess( "bad phrase rule!" ) unless $phrasal_rule;
  return ( { error => "exceeded maximum recursion depth ($max_depth)" } ) if ( $current_depth > $max_depth );

  my $num_words = scalar( @$sentence );
  return ( { error => "insufficient words to license phrase" } )
    if ( $from >= $num_words );

  my $target_label = $phrasal_rule->{label};

  my @node_list = @{ $phrasal_rule->{node} };

  my @error = ();

  my $method = { lexical => \&license_lexical_rule,
                 phrasal => \&license_phrasal_rule, };

  my @decomp = ( [] );
  for ( my $node_num = 0; $node_num < scalar @node_list; $node_num++ ) {
    my $node       = $node_list[$node_num];
    my $node_label = $node->cat->label;
    my $cat_type   = $node->cat->ctype;

    my $r;
    if ( $cat_type eq 'phrasal' ) {
      $r = $rule->{$node_label};
    } elsif ( $cat_type eq 'lexical' ) {
      $r = $node;
    }

    my @arg = ( $sentence, $from, $r, $max_depth, $current_depth + 1 );

    my $optional   = $node->optional;
    my $repeat     = $node->rpt;
    my $const_list = [];
    if ( exists $constByLabel->{$node_label} ) {
      $const_list = $constByLabel->{$node_label};
    } else {
      $constByLabel->{$node_label} = $const_list;
    }

    my $optAtPos = {};

    for ( my $decomp_num = 0; $decomp_num < scalar @decomp; $decomp_num++ ) {
      my $decomp = $decomp[$decomp_num];

      my $curpos = ( scalar @$decomp ? $decomp->[-1]->topos : $from );

      next if $curpos == $num_words;

      $arg[1] = $curpos;

      if ( $optional && !exists $optAtPos->{$curpos} ) {
        my $num = scalar @$const_list;
        my $constituent =
          Syntactic::Practice::Parser::Constituent->new( name          => "${node_label}${num}",
                                                         label         => $node_label,
                                                         sentence      => $sentence,
                                                         frompos       => $curpos,
                                                         topos         => $curpos,
                                                         cat_type      => $cat_type,
                                                         decomposition => [], );

        $optAtPos->{$curpos} = $constituent;
        push( @$const_list, $constituent );
        splice( @decomp, $decomp_num++, 0, [ @$decomp, $constituent ] );
      }

      my ( @result ) = $method->{$cat_type}->( @arg );

      # remove placeholder ; replaced below unless there is an error
      splice( @decomp, $decomp_num, 1 );

      if ( ref $result[0] eq 'HASH' && exists $result[0]->{error} ) {
        push( @error, $result[0] );
        $decomp_num--;
        next;
      }

      foreach my $d ( @result ) {
        splice( @decomp, $decomp_num, 0, [ @$decomp, $d ] );
        splice( @decomp, $decomp_num, 0, [ @$decomp, $d ] ) if ( $repeat );
      }
    }
  }

  my $const_list = [];
  if ( exists $constByLabel->{$target_label} ) {
    $const_list = $constByLabel->{$target_label};
  } else {
    $constByLabel->{$target_label} = $const_list;
  }

  my @return = ();
  while ( my $d = shift( @decomp ) ) {
    my $num = scalar @$const_list;
    my %const_args = ( label         => $target_label,
                       sentence      => $sentence,
                       frompos       => $from,
                       cat_type      => 'phrasal',
                       name          => "${target_label}${num}",
                       topos         => $d->[-1]->topos,
                       decomposition => $d );

    my $constituent = Syntactic::Practice::Parser::Constituent->new( %const_args );

    push( @$const_list, $constituent );
    push( @return,      $constituent );
  }

  # De-duplicate
  my @return_copy = @return;
  my @second_copy = @return_copy;
  my @unique;
  while ( my $l = shift( @second_copy ) ) {
    my @dup = grep { compare_constituents( $l, $_ ) == 0 } @return_copy;
    my @sorted = sort { $a->name cmp $b->name } ( @dup );
    $l           = $sorted[0];
    @unique      = grep { compare_constituents( $_, $l ) != 0 } @return_copy;
    @return_copy = ( @unique, $l );
  }
  @return = @return_copy;

  return @return if scalar @return;
  return @error;
}

sub compare_constituents {
  my ( $a, $b ) = @_;

  my $result;
  foreach my $attribute ( qw(label frompos topos cat_type) ) {
    $result = $a->$attribute cmp $b->$attribute;
    return $result unless $result == 0;
  }

  my @a_decomp = grep { $_->frompos != $_->topos } @{ $a->decomposition };
  my @b_decomp = grep { $_->frompos != $_->topos } @{ $b->decomposition };

  $result = scalar @a_decomp <=> scalar @b_decomp;
  return $result unless $result == 0;

  for ( my $num_decomp = 0; $num_decomp < scalar @a_decomp; $num_decomp++ ) {
    $result = compare_constituents( $a_decomp[$num_decomp], $b_decomp[$num_decomp] );
    return $result unless $result == 0;
  }

  return 0;
}

sub print_tree {
  my ( $constituent, $depth ) = @_;
  $depth = 0 unless $depth;
  my $indent = " " x ( $depth * 2 );
  print( $indent, $constituent->name, "\n" ) unless $depth > 0;
  foreach my $d ( @{ $constituent->decomposition } ) {
    next if ( $d->frompos == $d->topos );
    my @word = ( @{ $constituent->sentence } )[ $d->frompos .. $d->topos - 1 ];
    print( $indent, $d->name, ": @word\n" );
    print_tree( $d, $depth + 1 ) if $d->cat_type eq 'phrasal';
  }
}

